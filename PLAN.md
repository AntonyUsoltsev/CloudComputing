## Уточнённая формулировка задачи

Целью работы является разработка библиотеки и набора сервисов на языке Java, реализующих механизм распределённого
исполнения вычислений в кластере предварительно зарегистрированных узлов (worker’ов).

С точки зрения прикладного программиста вызов удалённой функции должен быть семантически эквивалентен локальному вызову,
а также не требовать предварительного развёртывания пользовательского приложения на удалённых узлах. Для этого система
должна обеспечивать маршалинг и передачу как данных, так и исполняемого кода.

Решение ориентировано на вычислительно тяжёлые задачи и задачи с большими объёмами данных, где накладные расходы на
сетевое взаимодействие оправданы.

## 1. Базовые требования

1. Передача и запуск кода и данных
    1. Клиентское приложение формирует задание, включающее:
        1. ссылку на исполняемую функцию (или её байткод)
        2. сериализованные аргументы
        3. метаданные задачи
    2. Диспетчер выбирает подходящий worker и перенаправляет задание
    3. Worker:
        1. при необходимости загружает код
        2. выполняет вычисление
        3. возвращает результат или информацию об ошибке

2. Балансировка нагрузки
    1. Диспетчер поддерживает реестр активных worker’ов
    2. Для каждого worker’а отслеживается число активных задач и состояние (alive / unavailable)
    3. Выбор узла производится по принципу минимальной текущей загрузки

3. Декларация удалённо исполняемой функции
    1. В Java декларация удалённого исполнения реализуется одним из способов:
        1. аннотация
        2. либо обёртка над Serializable / Callable<T> / Function<T,R>

4. Распределённый parallel map
   Реализуется аналог map, который
    1. разбивает входную коллекцию на чанки
    2. распределяет чанки между worker’ами
    3. внутри worker’а использует пул потоков по числу доступных ядер
    4. собирает результаты в единый результа

## 2. Архитектура решения

### 2.1. Основные компоненты

### Dispatcher

Dispatcher — центральный сервис системы, отвечающий за управление распределённым выполнением задач.

Основные функции Dispatcher:

- регистрация и учёт worker-узлов
- приём задач от клиентской библиотеки
- выбор узла для выполнения задачи
- балансировка нагрузки между worker'ам
- хранение состояния и метаданных задач

Взаимодействие с Dispatcher осуществляется по сети (REST).

### Worker

Worker — исполнительный узел кластера, реализованный в виде отдельного Java-сервиса.

Функции Worker:

- регистрация у Dispatcher при запуске
- периодическая отправка heartbeat-сообщений
- приём задач на выполнение
- динамическая загрузка и кэширование исполняемого кода
- выполнение вычислений с использованием пула потоков
- отправка результатов выполнения или информации об ошибке Dispatcher’у

Для динамической загрузки кода используется отдельный `ClassLoader`.  
Загруженные классы и артефакты кэшируются по хэшу байткода.

### Client library  

Client library представляет собой Java-библиотеку, используемую прикладными программами для взаимодействия с кластером.

Библиотека предоставляет:

- API для декларации удалённо исполняемых функций
- синхронные и асинхронные вызовы удалённых вычислений
- реализацию распределённого parallel map
- обработку сетевых ошибок, таймаутов и исключений

Client library скрывает сетевое взаимодействие и детали распределённого исполнения от пользователя.

--- 

## 3. Передача кода и данных

### 3.1. Базовая версия

В рамках базовой версии системы обеспечивается передача как данных, так и исполняемого кода между компонентами кластера.

**Передача данных** осуществляется в сериализованном виде. Допускается использование:

- стандартной Java Serialization;
- либо сторонних библиотек сериализации (Jackson, Kryo, Orika).

Конкретный способ сериализации фиксируется в реализации и используется единообразно во всех компонентах системы.

**Передача кода** осуществляется в виде Java-байткода (?)

- отдельных файлов `.class`
- либо архивов `.jar`, содержащих необходимые классы

На стороне worker’а исполняемый код загружается динамически с использованием собственного `ClassLoader`.

### 3.2. Кэширование кода

Каждый worker поддерживает кэш загруженного кода.  
Код идентифицируется по хэшу байткода.

При получении задания worker:

- проверяет наличие требуемого кода в локальном кэше
- загружает код только в случае его отсутствия
- повторно использует ранее загруженные классы при выполнении последующих задач

## 4. План выполнения работ

| Этап                                    | Содержание работ                                                                                                  | Результаты этапа                                                                | Ответственность                       |
|-----------------------------------------|-------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|---------------------------------------|
| Формулировка задачи                     | Анализ требований, уточнение постановки задачи, проектирование архитектуры, определение API клиентской библиотеки | Документ с уточнённой формулировкой задачи, архитектурой системы и планом работ | А - Архитектура, H - документы и план |
| Реализация базовой функциональности     | Реализация Dispatcher и Worker, организация передачи кода и данных, балансировка нагрузки                         | Рабочий прототип системы распределённых вычислений                              | A - Dispatcher, H - Worker            |
| Клиентская библиотека и distributed map | Разработка клиентского API, реализация распределённого parallel map, примеры использования                        | Клиентская библиотека и примеры выполнения распределённых вычислений            | Оба                                   |
| Расширенная функциональность            | Асинхронный запуск задач, мониторинг прогресса, оптимизация передачи кода                                         | Поддержка асинхронных вычислений и оптимизаций                                  | Оба                                   |
| Тестирование и документация             | Тесты, JavaDoc, подготовка демонстрационных примеров                                                              | Набор тестов, документация и примеры использования                              | A - Javadoc + demo, H - тесты         |
